#!/usr/bin/env python3
"""
Compatibility YAML loader for schema_hints.yaml.

This module provides a simple YAML loader that tries to use PyYAML if available,
but falls back to a simple parser that can handle the specific format used by
the schema hints file.

Usage:
    from scripts.compat_yaml import load_hints
    
    hints = load_hints('db/schema_hints.yaml')
"""

import re
from pathlib import Path
from typing import Dict, Any, Optional


def load_hints(path: str) -> Optional[Dict[str, Any]]:
    """
    Load schema hints from a YAML file.
    
    Tries to use PyYAML if available, otherwise uses a simple parser
    for the specific format produced by analyze_modules_columns.py.
    
    Args:
        path: Path to the schema_hints.yaml file
        
    Returns:
        Dictionary containing the parsed hints, or None if loading fails
    """
    path_obj = Path(path)
    
    if not path_obj.exists():
        return None
    
    # Try PyYAML first
    try:
        import yaml
        with open(path_obj, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    except ImportError:
        pass
    except Exception as e:
        print(f"Warning: PyYAML failed to load {path}: {e}")
    
    # Fall back to simple parser
    try:
        return _simple_yaml_parser(path_obj)
    except Exception as e:
        print(f"Error: Failed to parse {path}: {e}")
        return None


def _simple_yaml_parser(path: Path) -> Dict[str, Any]:
    """
    Simple YAML parser for the specific format used by schema_hints.yaml.
    
    Expected format:
        schema_version: "1.0"
        generated_by: "analyzer"
        tables:
          table_name:
            expected_columns:
              column_name:
                type: "TEXT"
                inferred: true
    
    Args:
        path: Path to the YAML file
        
    Returns:
        Parsed dictionary
    """
    with open(path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    result = {}
    current_dict = result
    stack = [(result, 0)]  # Stack of (dict, indent_level)
    
    for line in content.split('\n'):
        # Skip comments and empty lines
        stripped = line.strip()
        if not stripped or stripped.startswith('#'):
            continue
        
        # Calculate indentation level (spaces, assuming 2-space indent)
        indent = len(line) - len(line.lstrip())
        
        # Parse key-value pairs
        if ':' in line:
            parts = line.split(':', 1)
            key = parts[0].strip()
            value_str = parts[1].strip() if len(parts) > 1 else ''
            
            # Adjust stack based on indentation
            while stack and stack[-1][1] >= indent:
                stack.pop()
            
            # Parse value
            if value_str:
                # Simple value (string, number, boolean)
                value = _parse_value(value_str)
                if stack:
                    stack[-1][0][key] = value
            else:
                # Nested dictionary
                new_dict = {}
                if stack:
                    stack[-1][0][key] = new_dict
                stack.append((new_dict, indent))
    
    return result


def _parse_value(value_str: str) -> Any:
    """
    Parse a simple YAML value.
    
    Args:
        value_str: String representation of the value
        
    Returns:
        Parsed value (str, int, float, bool, or None)
    """
    # Remove quotes if present
    value_str = value_str.strip()
    
    if value_str.startswith('"') and value_str.endswith('"'):
        return value_str[1:-1]
    if value_str.startswith("'") and value_str.endswith("'"):
        return value_str[1:-1]
    
    # Boolean
    if value_str.lower() == 'true':
        return True
    if value_str.lower() == 'false':
        return False
    
    # None/null
    if value_str.lower() in ('null', 'none', '~'):
        return None
    
    # Number
    try:
        if '.' in value_str:
            return float(value_str)
        return int(value_str)
    except ValueError:
        pass
    
    # Default to string
    return value_str


if __name__ == "__main__":
    # Test the loader
    import sys
    
    if len(sys.argv) > 1:
        test_path = sys.argv[1]
    else:
        # Default test path
        repo_root = Path(__file__).parent.parent
        test_path = repo_root / "db" / "schema_hints.yaml"
    
    print(f"Testing YAML loader with: {test_path}")
    hints = load_hints(str(test_path))
    
    if hints:
        print(f"\nSuccessfully loaded hints!")
        print(f"Schema version: {hints.get('schema_version')}")
        print(f"Generated by: {hints.get('generated_by')}")
        
        if 'tables' in hints:
            print(f"\nFound {len(hints['tables'])} tables:")
            for table_name in sorted(hints['tables'].keys())[:5]:
                cols = hints['tables'][table_name].get('expected_columns', {})
                print(f"  - {table_name}: {len(cols)} columns")
            
            if len(hints['tables']) > 5:
                print(f"  ... and {len(hints['tables']) - 5} more tables")
    else:
        print("Failed to load hints")
        sys.exit(1)
